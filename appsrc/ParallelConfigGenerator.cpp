/*
 * Copyright (C)2015,2016,2017 Amos Brocco (amos.brocco@supsi.ch)
 *                             Scuola Universitaria Professionale della
 *                             Svizzera Italiana (SUPSI)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Scuola Universitaria Professionale della Svizzera
 *       Italiana (SUPSI) nor the names of its contributors may be used
 *       to endorse or promote products derived from this software without
 *       specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "ParallelConfigGenerator.h"
#include <boost/property_tree/json_parser.hpp>
#include <cstdlib>

namespace poma {
	
ParallelConfigGenerator::ParallelConfigGenerator(std::string& p_source_mid, std::map<std::string,Module>& p_modules, std::vector<Link>& p_links)
	: m_source_mid{p_source_mid}, m_modules{p_modules}, m_links{p_links}
{
}

void ParallelConfigGenerator::process() {
	bool invalidated{true};
	while (invalidated) {
		invalidated = false;
		for (auto &it : m_modules) {
			Module &m{m_modules[it.first]};
			if (m.mparams.count("#parallel") > 0 && m.mparams.count("#threadcount") <= 0) {
				m.mparams["#threadcount"] = m.mparams["#parallel"]; // Used to determine resource allocation needs
				create_fork_bridge(m, m.mparams["#parallel"]);
				invalidated = true;
				break;
			} else if (m.mtype == "ParExecutor" && m.mparams.count("#autogenerated") <= 0) {
				auto template_link = std::find_if(m_links.begin(), m_links.end(),
												  [&](const Link &l) {
													  return l.fid == m.mid && l.channel == "template";
												  });
				if (template_link != m_links.end()) {
					recursive_insert_thread_info(template_link->tid, m.mparams["#threadcount"]);
				}
			}
		}
	}
}

void ParallelConfigGenerator::recursive_insert_thread_info(const std::string& mid, const std::string& threadcount)
{
	if (m_modules.count(mid) <= 0) {
		die("Link points to unknown node");
	}
	Module &tm{m_modules[mid]}; // Module in the template line
	if (tm.mtype == "Joiner") {
		return;
	} else {
		tm.mparams["#threadcount"] = threadcount;
		// Find all outgoing links, fix them
		auto it = std::find_if(m_links.begin(), m_links.end(),
							   [&](const Link &l) { return l.fid == mid; });
		while (it != m_links.end()) {
			recursive_insert_thread_info(it->tid, threadcount);
			it = std::find_if(it, m_links.end(),
							  [&](const Link &l) { return l.fid == mid; });
		}
	}
}

void ParallelConfigGenerator::create_fork_bridge(Module m, const std::string& num_threads)
{
	Module fork;
	fork.mid = Module::unique("__parexecutor_");
	fork.mtype = "ParExecutor";
	fork.mhost = m.mhost;
	fork.mparams["threads"] = num_threads;
	fork.mparams["#autogenerated"] = "true";
	m_modules[fork.mid] = fork;
	Module joiner;
	joiner.mid = Module::unique("__joiner_");
	joiner.mtype = "Joiner";
	joiner.mhost = m.mhost;
    joiner.mparams["#autogenerated"] = "true";
	m_modules[joiner.mid] = joiner;
    // Fix links (that now go through the ParExecutor module
	for (auto& l : m_links) {
	    if (l.tid == m.mid) {
            // A->B becomes A->F
	        l.tid = fork.mid;
	    } else if (l.fid == m.mid) {
	        // B->C becomes
            l.fid = fork.mid;
	    }
	}
	// Create link from the ParExecutor to the original module
	Link templatefork;
	templatefork.fid = fork.mid;
	templatefork.tid = m.mid;
	templatefork.channel = "template";
	m_links.push_back(templatefork);
    // Create link from the original module to the Joiner
	Link joinerlink;
	joinerlink.fid = m.mid;
	joinerlink.tid = joiner.mid;
	joinerlink.channel = "default";
	m_links.push_back(joinerlink);
    // Create link from the ParExecutor to the original module
	Link backlink;
	backlink.fid = joiner.mid;
	backlink.tid = fork.mid;
	backlink.channel = "_join";
	m_links.push_back(backlink);
}
	
	
}
