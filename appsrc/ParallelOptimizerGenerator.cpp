//
// Created by attila on 21.08.18.
//

#include "ParallelOptimizerGenerator.h"
#include <boost/property_tree/json_parser.hpp>
#include <algorithm>

namespace poma {

    ParallelOptimizerGenerator::ParallelOptimizerGenerator(std::istream &pipeline) {
        boost::property_tree::ptree pt;
        boost::property_tree::json_parser::read_json(pipeline, pt);
        boost::property_tree::ptree jmodules{pt.get_child("modules.")};
        m_source_mid = pt.get("source", "");
        // Process modules
        for(auto &m : jmodules) {
            Module mod;
            mod.mid = m.first.data();
            if (mod.mid.find("#") == 0) continue; // disabled modules
            for (auto &md : m.second) {
                if (md.first == "type") {
                    mod.mtype = md.second.data();
                } else if (md.first == "cparams") {
                    for (auto &cp : md.second) {
                        mod.cparams.push_back(cp.second.data());
                    }
                } else if (md.first == "#host") {
                    mod.mhost = md.second.data();
                } else {
                    mod.mparams[md.first] = md.second.data();
                }
            }
            if (mod.mtype == "") {
                die("invalid module type definition: " + mod.mtype);
            }
            m_modules.push_back(mod);
        }
        // Process links
        boost::property_tree::ptree jlinks{pt.get_child("links.")};
        for(auto &l : jlinks) {
            Link lnk;
            for (auto &ld : l.second) {
                if (ld.first == "from") {
                    lnk.fid = ld.second.data();
                } else if (ld.first == "to") {
                    lnk.tid = ld.second.data();
                } else if (ld.first == "channel") {
                    lnk.channel = ld.second.data();
                } else if (ld.first == "debug") {
                    if (ld.second.data() == "true") {
                        lnk.debug = true;
                    }
                }
            }
            if (lnk.fid.find("#") == 0 || lnk.tid.find("#") == 0) continue; // commented modules

            if (lnk.channel == "") {
                die("invalid link definition: channel cannot be empty");
            }
            m_links.push_back(lnk);
        }
    }

    void ParallelOptimizerGenerator::generate(std::ostream &output) {
        std::vector<std::string> unnecessary_modules;
        // Find autogenerated Fork
        auto autogenerated_fork_test{[&] (const Module& m) {return m.mtype == "ParExecutor" && m.mparams.count("#autogenerated") > 0;}};
        bool invalidated_vector{true};
        while(invalidated_vector) {
            invalidated_vector = false;
            for (auto it{std::find_if(m_modules.begin(), m_modules.end(), autogenerated_fork_test)};
                 it != m_modules.end();
                 it = std::find_if(++it, m_modules.end(), autogenerated_fork_test))
            {
                // Find all outgoing links from this module
                long count{std::count_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == it->mid;})};
                // If there is only one outgoing link
                if (count == 1) {
                    // Check if it goes to another ParExecutor autogenerated module
                    auto lnk{std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == it->mid;})};
                    if (lnk == m_links.end()) {
                        continue;
                    }
                    auto mod{std::find_if(m_modules.begin(), m_modules.end(), [&] (const Module& m) { return m.mid == lnk->tid; })};
                    if (mod == m_modules.end()) {
                        continue;
                    }
                    if (autogenerated_fork_test(*mod)) {
                        // If so, merge the two modules
                        if (merge_parallel_modules(*it, *mod)) {
                            invalidated_vector = true;
                            break;
                        } else {
                            die("Inconsistent pipeline");
                        }
                    }
                }
            }
        }
        boost::property_tree::ptree pt;
        boost::property_tree::ptree modules;
        boost::property_tree::ptree links;
        pt.put("source", m_source_mid);
        for (const auto& module : m_modules) {
            boost::property_tree::ptree data;
            data.put("type", module.mtype);
            for(auto& pit : module.mparams) {
                data.put(pit.first, pit.second);
            }
            if (module.cparams.size() > 0) {
                boost::property_tree::ptree cpar;
                for (const auto& v : module.cparams) {
                    boost::property_tree::ptree value;
                    value.put("", v);
                    cpar.push_back(std::make_pair("", value));
                }
                data.add_child("cparams", cpar);
            }
            modules.add_child(module.mid, data);
        }

        for (const auto& link : m_links) {
            boost::property_tree::ptree data;
            data.put("from", link.fid);
            data.put("to", link.tid);
            data.put("channel", link.channel);
            data.put("debug", link.debug);
            links.push_back(std::make_pair("", data));
        }

        pt.add_child("modules", modules);
        pt.add_child("links", links);
        boost::property_tree::write_json (output, pt, true);
    }

    void ParallelOptimizerGenerator::die(const std::string &msg) {
        std::cerr << msg << std::endl;
        std::exit(-1);
    }

    bool ParallelOptimizerGenerator::merge_parallel_modules(Module a, Module b) {
        // Determine Ma (tid of link with fid == a.mid and channel == "template")
        auto ita = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == a.mid && l.channel == "template"; });
        if (ita == m_links.end()) {
            return false;
        }
        std::string ma = ita->tid;
        // Determine Mb (tid of link with fid == b.mid and channel == "template")
        auto itb = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == b.mid && l.channel == "template"; });
        if (itb == m_links.end()) {
            return false;
        }
        std::string mb = itb->tid;
        // Determine Ja (tid of link with fid == ma)
        auto itja = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == ma; });
        if (itja == m_links.end()) {
            return false;
        }
        std::string ja = itja->tid;
        // Determine Jb (tid of link with fid == mb)
        auto itjb = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == mb; });
        if (itjb == m_links.end()) {
            return false;
        }
        std::string jb = itjb->tid;
        // Remove link from a to b
        std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == a.mid && l.tid == b.mid; });
        // Remove link from b to Mb
        std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == b.mid && l.tid == mb; });
        // Remove link between Joiner module (Jb) and B
        std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == jb && l.tid == b.mid; });
        // Remove link between Mb and Joiner module Jb
        std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == mb && l.tid == jb; });
        // Remove link between Ma and Joiner module Ja
        std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == ma && l.tid == ja; });
        // Create link between Ma and Mb
        Link link;
        link.fid = ma;
        link.tid = mb;
        link.channel = "default";
        m_links.push_back(link);
        // Create link between Mb and Ja
        Link jlink;
        jlink.fid = mb;
        jlink.tid = ja;
        jlink.channel = "default";
        m_links.push_back(jlink);
        // Change all links from B to originate from A
        for (auto& l : m_links) {
            if (l.fid == b.mid) {
                l.fid = a.mid;
            }
        }
        // Remove Joiner module (Jb)
        std::remove_if(m_modules.begin(), m_modules.end(), [&] (const Module& m) { return m.mid == jb; });
        // Remove module B
        std::remove_if(m_modules.begin(), m_modules.end(), [&] (const Module& m) { return m.mid == b.mid; });
        return true;
    }


}
