//
// Created by attila on 21.08.18.
//

#include "ParallelOptimizerGenerator.h"
#include <boost/property_tree/json_parser.hpp>
#include <algorithm>
#include <utility>

namespace poma {

    ParallelOptimizerGenerator::ParallelOptimizerGenerator(std::string& p_source_mid, std::map<std::string,Module>& p_modules, std::vector<Link>& p_links)
            : m_source_mid{p_source_mid}, m_modules{p_modules}, m_links{p_links} {
    }

    void ParallelOptimizerGenerator::process() {
        // Find autogenerated Fork
        auto autogenerated_fork_test{[&] (const std::pair<std::string,Module>& m) {return m.second.mtype == "ParExecutor" && m.second.mparams.count("#autogenerated") > 0;}};
        bool invalidated_vector{true};
        while(invalidated_vector) {
            invalidated_vector = false;
            for (auto it{std::find_if(m_modules.begin(), m_modules.end(), autogenerated_fork_test)};
                 it != m_modules.end();
                 it = std::find_if(++it, m_modules.end(), autogenerated_fork_test))
            {
                // Find all outgoing links from this module
                long count{std::count_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == it->second.mid;})};
                // If there is only one outgoing link
                if (count == 1) {
                    // Check if it goes to another ParExecutor autogenerated module
                    auto lnk{std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == it->second.mid;})};
                    if (lnk == m_links.end()) {
                        continue;
                    }
                    auto mod{std::find_if(m_modules.begin(), m_modules.end(), [&] (const std::pair<const std::string,Module>& m) { return m.second.mid == lnk->tid; })};
                    if (mod == m_modules.end()) {
                        continue;
                    }
                    // Merge only ParExecutors with the same number of threads
                    if (autogenerated_fork_test(*mod) && it->second.mparams["threads"] == mod->second.mparams["threads"]) {
                        // If so, merge the two modules
                        if (merge_parallel_modules(it->second, mod->second)) {
                            invalidated_vector = true;
                            break;
                        } else {
                            die("Inconsistent pipeline");
                        }
                    }
                }
            }
        }
    }

    bool ParallelOptimizerGenerator::merge_parallel_modules(Module a, Module b) {
        // Determine Ma (tid of link with fid == a.mid and channel == "template")
        auto ita = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == a.mid && l.channel == "template"; });
        if (ita == m_links.end()) {
            return false;
        }
        std::string ma = ita->tid;
        // Determine Mb (tid of link with fid == b.mid and channel == "template")
        auto itb = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == b.mid && l.channel == "template"; });
        if (itb == m_links.end()) {
            return false;
        }
        std::string mb = itb->tid;
        // Determine Ja (tid of link with fid == ma)
        auto itja = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == ma; });
        if (itja == m_links.end()) {
            return false;
        }
        std::string ja = itja->tid;
        // Determine Jb (tid of link with fid == mb)
        auto itjb = std::find_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == mb; });
        if (itjb == m_links.end()) {
            return false;
        }
        std::string jb = itjb->tid;
        // Remove link from a to b
        m_links.erase(std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == a.mid && l.tid == b.mid; }));
        // Remove link from b to Mb
        m_links.erase(std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == b.mid && l.tid == mb; }));
        // Remove link between Joiner module (Jb) and B
        m_links.erase(std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == jb && l.tid == b.mid; }));
        // Remove link between Mb and Joiner module Jb
        m_links.erase(std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == mb && l.tid == jb; }));
        // Remove link between Ma and Joiner module Ja
        m_links.erase(std::remove_if(m_links.begin(), m_links.end(), [&] (const Link& l) { return l.fid == ma && l.tid == ja; }));
        // Create link between Ma and Mb
        Link link;
        link.fid = ma;
        link.tid = mb;
        link.channel = "default";
        m_links.push_back(link);
        // Create link between Mb and Ja
        Link jlink;
        jlink.fid = mb;
        jlink.tid = ja;
        jlink.channel = "default";
        m_links.push_back(jlink);
        // Change all links from B to originate from A
        for (auto& l : m_links) {
            if (l.fid == b.mid) {
                l.fid = a.mid;
            }
        }
        // Remove Joiner module (Jb)
        for(auto it = m_modules.begin(); it != m_modules.end();) {
            if(it->second.mid == jb)
                it = m_modules.erase(it);
            else
                ++it;
        }
        // Remove module B
        for(auto it = m_modules.begin(); it != m_modules.end();) {
            if(it->second.mid == b.mid)
                it = m_modules.erase(it);
            else
                ++it;
        }
        return true;
    }


}
